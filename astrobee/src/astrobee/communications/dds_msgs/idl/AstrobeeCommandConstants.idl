
/*
 * Copyright (c) 2015 United States Government as represented by the
 * Administrator of the National Aeronautics and Space Administration.
 * All Rights Reserved.
 */

#include "BaseTypes.idl"

/**
 * \file
 *
 * \brief AstrobeeCommandConstants.idl extends the RAPID CommandConstants.idl file
 * with Astrobee-specific commands.
 *
 * \details Refer to RAPID CommandConstants.idl for interpretation.
 *
 * \ingroup idlfiles
 */
module rapid {
  module ext {
    module astrobee {
      const rapid::String32 ACCESSCONTROL = "AccessControl";

      //@copy-declaration /** Grabs control of an Astrobee.<p/>The Astrobee control station implements the RAPID access control protocol, which includes the following steps:<ol><li>Use Admin.requestCookie to get a unique cookie.</li><li>Use this Admin.grabControl command to grab control. Include the cookie received in step 1.</li></ol>The RAPID access control protocol exists to prevent accidental contention between different operators. Each robot can be under the control of at most one control station at a time. The robot will reject most commands from other control stations, but a few exceptions are made for commands that might be urgently needed to safe the system: any control station can send the Mobility.stopAllMotion and Mobility.idlePropulsion commands. A single control station can grab control of multiple robots, for example, to manage multi-robot guest science. Note that guest science apps running onboard the robot do not need to grab control of the robot to send commands; there is no mechanism to prevent contention between a guest science app and a control station. */
      const rapid::String32 ACCESSCONTROL_METHOD_GRAB_CONTROL = "grabControl";

      const rapid::String32 ACCESSCONTROL_METHOD_GRAB_CONTROL_PARAM_COOKIE = "cookie";
      const rapid::DataType ACCESSCONTROL_METHOD_GRAB_CONTROL_DTYPE_COOKIE = rapid::RAPID_STRING;

      const rapid::String32 ADMIN = "Admin";

      //@copy-declaration /** For internal use only. Places the robot in a fault state. This command can only be sent by Astrobee's onboard executive or system monitor nodes. The executive will reject the command if it comes from any other source. */
      const rapid::String32 ADMIN_METHOD_FAULT = "fault";

      //@copy-declaration /** Calibrates the bias parameters of Astrobee's IMU.<p/>Astrobee's IMU biases slowly drift over time. While Astrobee is actively running its localization system and maintaining a position fix, its EKF automatically corrects for bias drift under the assumption that the local environment is inertially fixed. If the localization system is turned off or loses its fix for an extended period, this command should be used to explicitly calibrate the biases prior to restarting motion. It works by integrating the robot's linear acceleration and angular velocity for about five seconds, and taking the resulting average values as the new zero. During the calibration period, the robot must remain stationary (e.g. docked or perched on a handrail, not held by an astronaut). */
      const rapid::String32 ADMIN_METHOD_INITIALIZE_BIAS = "initializeBias";

      //@copy-declaration /** This command is intended to load a ROS nodelet in the Astrobee flight software. Please note, the underlying system monitor service can't load nodelets that run on the HLP. */
      const rapid::String32 ADMIN_METHOD_LOAD_NODELET = "loadNodelet";

      //@copy-declaration /** Name of nodelet */
      const rapid::String32 ADMIN_METHOD_LOAD_NODELET_PARAM_NODELET_NAME = "nodeletName";
      const rapid::DataType ADMIN_METHOD_LOAD_NODELET_DTYPE_NODELET_NAME = rapid::RAPID_STRING;

      //@copy-declaration /** Which nodelet manager should load the nodelet. If left blank, the system monitor will default to using the managerName specified in the last heartbeat it received from the requested nodelet. (That should normally work fine, assuming the nodelet sent out at least one valid heartbeat.) */
      const rapid::String32 ADMIN_METHOD_LOAD_NODELET_PARAM_MANAGER_NAME = "managerName";
      const rapid::DataType ADMIN_METHOD_LOAD_NODELET_DTYPE_MANAGER_NAME = rapid::RAPID_STRING;

      //@copy-declaration /** Type of nodelet (namespace/classname). If left blank, the system monitor will default to the type specified in its config file, which should normally work fine. */
      const rapid::String32 ADMIN_METHOD_LOAD_NODELET_PARAM_TYPE = "type";
      const rapid::DataType ADMIN_METHOD_LOAD_NODELET_DTYPE_TYPE = rapid::RAPID_STRING;

      //@copy-declaration /** With the current implementation, you should leave this field blank. Specifying a non-empty string (unique id) will activate bond notifications.<p/>Background: ROS nodelets provide a 'bond' mechanism that enables the process requesting a nodelet load (in our case the system monitor) to receive automatic notification if that nodelet crashes. However, our system monitor instead relies on a custom heartbeat message to detect liveness, and it is not currently configured to do anything useful with bond notifications, even if they are activated. */
      const rapid::String32 ADMIN_METHOD_LOAD_NODELET_PARAM_BOND_ID = "bondId";
      const rapid::DataType ADMIN_METHOD_LOAD_NODELET_DTYPE_BOND_ID = rapid::RAPID_STRING;

      //@copy-declaration /** Switches Astrobee's localization to use the general-purpose pipeline.<p/>This command is equivalent to calling Admin.switchLocalization with the "MappedLandmarks" pipeline and then calling Admin.resetEKF. It could be useful as a way to manually recover localization if Astrobee is lost because it is using the wrong localization pipeline (e.g., if docking or perching approach got interrupted, and targets are no longer in view). */
      const rapid::String32 ADMIN_METHOD_REACQUIRE_POSITION = "reacquirePosition";

      //@copy-declaration /** Resets the EKF component of Astrobee's localization.<p/>This command discards the EKF state and forces the localization system to acquire a new fix. It should not be needed unless the localization system has failure modes where it gets persistently stuck with invalid state information. (Unfortunately, as of 10/2020, that is a frequent occurrence.) */
      const rapid::String32 ADMIN_METHOD_RESET_EKF = "resetEkf";

      //@copy-declaration /** This rarely used command manually switches between localization pipelines. Normally, Astrobee switches its localization pipeline automatically based on what activity it is conducting (normal free flight, docking, perching, etc.).<p/>Note that, although Astrobee could logically integrate information from multiple pipelines at the same time (e.g., NavCam sparse map features as well as DockCam AR targets), at present, it only uses data from one of these pipelines at a time. IMU information is always integrated, regardless of which pipeline is used. While switching pipelines from A to B, updates from A stop, then there may be a dropout period of a few seconds before B acquires a fix. During the dropout period, localization relies solely on the IMU. */
      const rapid::String32 ADMIN_METHOD_SWITCH_LOCALIZATION = "switchLocalization";

      //@copy-declaration /** Which pipeline to use:<ul><li>MappedLandmarks: General-purpose localization mode; Astrobee uses its NavCam to recognize landmark features on the ISS interior, as well as for visual odometry.</li><li>ARTags: During docking, Astrobee uses its DockCam to view AR tags located on the dock and obtain more robust and accurate localization.</li><li>Handrail: During perching approach, Astrobee uses its PerchCam LIDAR to recognize the geometry of a handrail in front of a wall.</li><li>Perch: Not implemented. While perched, Astrobee could use a simplified localization approach based on remembering its initial perched pose and updating its pose during pan/tilt motions using a kinematic model of the arm. </li><li>Truth: During lab testing, Astrobee can optionally subscribe to pose telemetry from an external ground-truth localization system and use it for motion control.</li></ul> */
      const rapid::String32 ADMIN_METHOD_SWITCH_LOCALIZATION_PARAM_MODE = "mode";
      const rapid::DataType ADMIN_METHOD_SWITCH_LOCALIZATION_DTYPE_MODE = rapid::RAPID_STRING;

      //@copy-declaration /** This command is intended to unload a ROS nodelet in Astrobee's flight software. Its primary use is in the system monitor's fault response table, where it is the usual response if initialization of a nodelet fails. Please note, the internal service can't unload nodes running on the HLP. */
      const rapid::String32 ADMIN_METHOD_UNLOAD_NODELET = "unloadNodelet";

      //@copy-declaration /** Name of nodelet */
      const rapid::String32 ADMIN_METHOD_UNLOAD_NODELET_PARAM_NODELET_NAME = "nodeletName";
      const rapid::DataType ADMIN_METHOD_UNLOAD_NODELET_DTYPE_NODELET_NAME = rapid::RAPID_STRING;

      //@copy-declaration /** Which nodelet manager should unload the nodelet. If left blank, the system monitor will default to using the managerName specified in the last heartbeat it received from the nodelet. (That should normally work fine, assuming the nodelet sent out at least one valid heartbeat.) */
      const rapid::String32 ADMIN_METHOD_UNLOAD_NODELET_PARAM_MANAGER_NAME = "managerName";
      const rapid::DataType ADMIN_METHOD_UNLOAD_NODELET_DTYPE_MANAGER_NAME = rapid::RAPID_STRING;

      //@copy-declaration /** Clears the terminate flag on the robot. This functionality is tied to Astrobee's physical terminate button and terminate indicator LED. The terminate life cycle is as follows:<ul><li>Nominal ops: When Astrobee is active, the amber terminate LED is turned on and the robot functions normally.</li><li>Terminate: A crew member may press the terminate button as a way to quickly power down the propulsion modules and payloads, while leaving the main processors running and able to communicate with the ground operator. This is a gentler way to intervene than turning off the physical power switch. While terminated, the terminate LED is also turned off.</li><li>Unterminate: The ground operator can send this command to clear the terminate flag and turn the terminate LED back on. This does <b>not</b> automatically restore power to the hardware.</li><li>Configure power: Send Power.powerOnItem commands as needed to restore power to individual hardware components.</li></ul> */
      const rapid::String32 ADMIN_METHOD_UNTERMINATE = "unterminate";

      //@copy-declaration /** Wakes an Astrobee from a hibernating state (only EPS powered) by powering up the main processors. This command is intended to also automatically start the flight software stack such that Astrobee is ready to receive Astrobee API commands, but that feature is not implemented.<p/>The Astrobee in question must be docked. Because each wake command is routed through a dock berth, which Astrobee to wake is specified using the berth number.<p/>See also Admin.wakeSafe. The difference between Admin.wake and Admin.wakeSafe is that Admin.wake is intended to automatically start the flight software stack. Since that feature is not implemented, at present, the two commands are equivalent.<p/>Note: For context about how to wake an Astrobee on the ISS, see the procedure IRG-FFTEST207a Astrobee Quick Wakeup and Checkout. */
      const rapid::String32 ADMIN_METHOD_WAKE = "wake";

      //@copy-declaration /** Which berth the Astrobee is using. 1=left, 2=right. */
      const rapid::String32 ADMIN_METHOD_WAKE_PARAM_BERTH_NUMBER = "berthNumber";
      const rapid::DataType ADMIN_METHOD_WAKE_DTYPE_BERTH_NUMBER = rapid::RAPID_INT;

      //@copy-declaration /** Wakes Astrobee from a hibernating state (only EPS powered) into a safe state (main processors powered, available to log in for debugging, but flight software stack not started).<p/>The Astrobee in question must be docked. Because each wake command is routed through a dock berth, which Astrobee to wake is specified using the berth number. See also Admin.wake. */
      const rapid::String32 ADMIN_METHOD_WAKE_SAFE = "wakeSafe";

      //@copy-declaration /** Which berth the Astrobee is using. 1=left, 2=right. */
      const rapid::String32 ADMIN_METHOD_WAKE_SAFE_PARAM_BERTH_NUMBER = "berthNumber";
      const rapid::DataType ADMIN_METHOD_WAKE_SAFE_DTYPE_BERTH_NUMBER = rapid::RAPID_INT;

      const rapid::String32 ARM = "Arm";

      //@copy-declaration /** Moves Astrobee's arm.<p/>The arm has two joints. The tilt joint is used to deploy/stow the arm and adjust the SciCam tilt angle while perched. The pitch joint is used to adjust the SciCam pan angle while perched.<p/>The (pan, tilt) = (0, 0) reference position is defined to have the arm fully deployed and aligned with the robot's -X axis. If perched on a handrail on an ISS wall, this position should nominally make the SciCam camera axis point directly toward the opposite wall. Increasing the tilt angle tilts the SciCam up, and increasing the pan angle pans the SciCam to the right. The arm's stowed position is (pan, tilt) = (0, 180).<p/>The arm joints will be moved sequentially:<ol><li>Pan: If which is "Pan" or "Both", pan to the specified pan angle.</li><li>Tilt: If which is "Tilt" or "Both", tilt to the specified tilt angle.</li></ol><p/>Naturally, if you prefer to tilt first, you can issue a tilt-only move, followed by a pan-only move.<p/>Some mistakes to avoid include:<ul><li>While the arm is partially within its payload bay (tilt > 90), the pan angle must be 0 to avoid the arm colliding with its payload bay.</li><li>While the arm is close to its fully stowed state (tilt > 160), the gripper must be closed to avoid colliding with the arm's payload bay.</li><li>While perched, the nominal tilt range of motion is restricted to -20 .. +90.</li><li>While perched, the arm may not be able to realize its full nominal range of motion without causing Astrobee's body to collide with the wall. The actual range of motion depends on clutter and how far the handrail projects from the wall.</li></ul> */
      const rapid::String32 ARM_METHOD_ARM_PAN_AND_TILT = "armPanAndTilt";

      //@copy-declaration /** The target pan angle. Ignored if which is "Tilt". */
      const rapid::String32 ARM_METHOD_ARM_PAN_AND_TILT_PARAM_PAN = "pan";
      const rapid::DataType ARM_METHOD_ARM_PAN_AND_TILT_DTYPE_PAN = rapid::RAPID_FLOAT;

      //@copy-declaration /** The target tilt angle. Ignored if which is "Pan". */
      const rapid::String32 ARM_METHOD_ARM_PAN_AND_TILT_PARAM_TILT = "tilt";
      const rapid::DataType ARM_METHOD_ARM_PAN_AND_TILT_DTYPE_TILT = rapid::RAPID_FLOAT;

      //@copy-declaration /** Specifies whether the arm needs to pan, tilt, or both. */
      const rapid::String32 ARM_METHOD_ARM_PAN_AND_TILT_PARAM_WHICH = "which";
      const rapid::DataType ARM_METHOD_ARM_PAN_AND_TILT_DTYPE_WHICH = rapid::RAPID_STRING;

      //@copy-declaration /** Deploys arm. The motion sequence is:<ol><li>Pan to 0</li><li>Tilt to 0</li></ol><p/>See also Arm.armPanAndTilt for more discussion of the arm. */
      const rapid::String32 ARM_METHOD_DEPLOY_ARM = "deployArm";

      //@copy-declaration /** Opens or closes gripper.<p/>Astrobee's arm has a passively under-actuated gripper with a single motor. Opening the gripper commands the motor to pull on a pair of tendons that open the fingers. Closing the gripper cuts power to the motor; the fingers are spring-loaded to close. The first time the gripper opens, it calibrates the motor encoder position by fully opening until the fingers contact a hard stop, then relaxes slightly to its nominal open position. On later open cycles, it opens directly to the nominal open position. Note that the motor consumes significant power holding the gripper open, so it should be closed when not actively in use. Holding it open for extended periods (minutes) runs the risk of triggering a motor overtemperature fault, which disables the motor. */
      const rapid::String32 ARM_METHOD_GRIPPER_CONTROL = "gripperControl";

      //@copy-declaration /** Set to true/false to open/close gripper. */
      const rapid::String32 ARM_METHOD_GRIPPER_CONTROL_PARAM_OPEN = "open";
      const rapid::DataType ARM_METHOD_GRIPPER_CONTROL_DTYPE_OPEN = rapid::RAPID_BOOL;

      //@copy-declaration /** Stops arm motion by commanding it to hold its current joint positions. Does not affect the gripper. */
      const rapid::String32 ARM_METHOD_STOP_ARM = "stopArm";

      //@copy-declaration /** Stows arm. The motion sequence is:<ol><li>Close gripper</li><li>Pan to 0</li><li>Tilt to 180</li></ol><p/>See also Arm.armPanAndTilt for more discussion of the arm. */
      const rapid::String32 ARM_METHOD_STOW_ARM = "stowArm";

      const rapid::String32 DATA = "Data";

      //@copy-declaration /** Sets the data-to-disk configuration, which specifies how to log ROS telemetry topics to the robot's onboard storage.<p/>The configuration is specified in a JSON-formatted file that contains a list of topic entries. For each logged topic, one specifies:<ul><li>frequency: Throttles the maximum rate at which to record messages on the topic. Specify -1 to disable throttling. Note: Currently, throttling is not implemented. You must specify -1.</li><li>downlinkOption: Which log to store messages in, which must be "Immediate" or "Delayed". The intent is that the "Immediate" log is for high-priority data, which can then be prioritized for downlink after the activity. Note: Currently, you must specify "Delayed" ("Immediate" downlink is currently reserved for internal use by the flight software stack).</li></ul>Sample data-to-disk configuration files can be found in astrobee_ops/gds/ControlStationConfig.<p/>The Astrobee control station implements the protocol for managing onboard telemetry recording:<ol><li>Uplink a new data-to-disk file using the RAPID compressed file protocol over DDS. (File uplink is not considered a command, so it does not appear in this command dictionary).</li><li>Send this Data.setDataToDisk command to load the uplinked file. Any errors in the file will be reported at this time.</li><li>Use the Data.startRecording / Data.stopRecording commands to start / stop onboard telemetry logging.</li></ol> */
      const rapid::String32 DATA_METHOD_SET_DATA_TO_DISK = "setDataToDisk";

      //@copy-declaration /** Starts logging ROS telemetry to onboard storage. See Data.setDataToDisk. */
      const rapid::String32 DATA_METHOD_START_RECORDING = "startRecording";

      //@copy-declaration /** An optional short description string to include in the filename of the stored telemetry file (ROS bag). Note that the filename always includes a timestamp, which ensures uniqueness. */
      const rapid::String32 DATA_METHOD_START_RECORDING_PARAM_DESCRIPTION = "description";
      const rapid::DataType DATA_METHOD_START_RECORDING_DTYPE_DESCRIPTION = rapid::RAPID_STRING;

      //@copy-declaration /** Stops logging ROS telemetry to onboard storage, as initiated by Data.startRecording. See also Data.setDataToDisk. */
      const rapid::String32 DATA_METHOD_STOP_RECORDING = "stopRecording";

      const rapid::String32 GUESTSCIENCE = "GuestScience";

      //@copy-declaration /** Routes a custom command to a guest science app (APK) running on the Astrobee HLP.<p/>For the convenience of the control station operator, each guest science app can define what custom commands it supports in a configuration file read by the control station. See astrobee_ops/gds/ControlStation/PlanEditorGuestScience.config.<p/>See GuestScience.startGuestScience for more on the guest science life cycle. */
      const rapid::String32 GUESTSCIENCE_METHOD_CUSTOM_GUEST_SCIENCE = "customGuestScience";

      //@copy-declaration /** Which guest science APK to send the command to */
      const rapid::String32 GUESTSCIENCE_METHOD_CUSTOM_GUEST_SCIENCE_PARAM_APK_NAME = "apkName";
      const rapid::DataType GUESTSCIENCE_METHOD_CUSTOM_GUEST_SCIENCE_DTYPE_APK_NAME = rapid::RAPID_STRING;

      //@copy-declaration /** The command to send (usually formatted as a JSON dictionary, enabling an arbitrary number and types of parameters). */
      const rapid::String32 GUESTSCIENCE_METHOD_CUSTOM_GUEST_SCIENCE_PARAM_COMMAND = "command";
      const rapid::DataType GUESTSCIENCE_METHOD_CUSTOM_GUEST_SCIENCE_DTYPE_COMMAND = rapid::RAPID_STRING;

      //@copy-declaration /** Starts a guest science app (APK) running on the Astrobee HLP. This command is part of the guest science app life cycle, implemented by the guest science manager node on the HLP. Steps of the life cycle include:<p/><ul><li>startGuestScience: Starts a guest science app, making it available to receive commands.</li><li>customGuestScience: Routes a command to a running guest science app.</li><li>stopGuestScience: Terminates a running guest science app.</li></ul> */
      const rapid::String32 GUESTSCIENCE_METHOD_START_GUEST_SCIENCE = "startGuestScience";

      //@copy-declaration /** Which guest science APK to start */
      const rapid::String32 GUESTSCIENCE_METHOD_START_GUEST_SCIENCE_PARAM_APK_NAME = "apkName";
      const rapid::DataType GUESTSCIENCE_METHOD_START_GUEST_SCIENCE_DTYPE_APK_NAME = rapid::RAPID_STRING;

      //@copy-declaration /** Terminates a guest science app (APK) running on the Astrobee HLP. See GuestScience.startGuestScience. */
      const rapid::String32 GUESTSCIENCE_METHOD_STOP_GUEST_SCIENCE = "stopGuestScience";

      //@copy-declaration /** Which guest science APK to terminate */
      const rapid::String32 GUESTSCIENCE_METHOD_STOP_GUEST_SCIENCE_PARAM_APK_NAME = "apkName";
      const rapid::DataType GUESTSCIENCE_METHOD_STOP_GUEST_SCIENCE_DTYPE_APK_NAME = rapid::RAPID_STRING;

      const rapid::String32 MOBILITY = "Mobility";

      //@copy-declaration /** For expert use only. Returns Astrobee to its dock.<p/>As originally envisioned, this operation could be commanded from anywhere on the ISS, and Astrobee would plan a collision-free path back to the dock. Auto-return could also be invoked as an automatic response to a low-battery fault. To avoid contention for dock berths when multiple Astrobees are in use, each Astrobee should return to the same berth it originally departed from.<p/>However, using this command is not recommended at this time, because (1) it has not been sufficiently tested (including testing of the QP trajectory planner), (2) at present, the proper berth selection logic is not implemented; instead, Astrobee will always return to berth 1 (= left). */
      const rapid::String32 MOBILITY_METHOD_AUTO_RETURN = "autoReturn";

      //@copy-declaration /** Docks Astrobee at the specified berth. Preconditions: Astrobee must be near the dock approach point for the specified berth, the berth approach path must not be blocked, and the dock AR tags must not be occluded.<p/>The nominal docking sequence is as follows:<ol><li>Switch to the "MappedLandmarks" localization pipeline (the default for general-purpose navigation).</li><li>Coarsely correct positioning at dock approach point, ensuring dock AR tags are in view.</li><li>Switch to "ARTags" localization pipeline (uses AR tags on dock for more accurate dock-relative localization).</li><li>Fine-tune positioning at dock approach point.</li><li>Complete the docking approach, which should end with Astrobee magnetically retained on the berth, with power and data pins in contact.</li><li>Check magnetic retention by attempting to fly away from the dock. Lack of motion indicates success.</li><li>Idle propulsion.</li><li>Disable localization system.</li></ol> */
      const rapid::String32 MOBILITY_METHOD_DOCK = "dock";

      //@copy-declaration /** Which berth the Astrobee is using. 1=left, 2=right. */
      const rapid::String32 MOBILITY_METHOD_DOCK_PARAM_BERTH_NUMBER = "berthNumber";
      const rapid::DataType MOBILITY_METHOD_DOCK_DTYPE_BERTH_NUMBER = rapid::RAPID_INT;

      //@copy-declaration /** Idles the propulsion impeller motors.<p/>Astrobee will lose control authority. If it is not grounded in some way (docked or perched), it will drift uncontrolled. Note that the impellers have significant inertia, and may take several seconds to spin down.<p/>This command is usually invoked automatically (e.g., at the end of successful docking or perching). It can also be used as a fault response (e.g., responding to an overspeed fault). */
      const rapid::String32 MOBILITY_METHOD_IDLE_PROPULSION = "idlePropulsion";

      //@copy-declaration /** Perches Astrobee on a handrail. The robot must already be near the appropriate perch approach point for the desired perch location, with the handrail in view of the PerchCam.<p/>The nominal perching sequence is as follows:<ol><li>Switch to the "Handrail" (handrail-relative) localization pipeline.</li><li>Fine-tune positioning at perch approach point.</li><li>Deploy arm.</li><li>Open gripper.</li><li>Move until handrail is in contact, within gripper capture box.</li><li>Close gripper.</li><li>Confirm grasp by attempting to fly away from the handrail. Lack of motion indicates success.</li><li>Idle propulsion.</li></ol> */
      const rapid::String32 MOBILITY_METHOD_PERCH = "perch";

      //@copy-declaration /** Manually spins up the propulsion modules, so that a future motion command can execute without a spin-up delay. This command is rarely used. Normally, you would just command the desired motion and the spin-up would be triggered automatically if needed. This command is intended to help with synchronizing motion of multiple Astrobees, but that scenario hasn't really been tested. */
      const rapid::String32 MOBILITY_METHOD_PREPARE = "prepare";

      //@copy-declaration /** Undocks Astrobee.<p/>The nominal undocking sequence is as follows:<ol><li>Switch to the "MappedLandmarks" localization pipeline (the default for general-purpose navigation).</li><li>Spin up impellers.</li><li>Command the dock berth retention magnets to retract, releasing Astrobee. (They will automatically re-extend after a fixed time delay.)</li><li>Move to the dock approach point. (Note: Astrobee attempts to move immediately, without waiting for the berth magnets to fully retract.)</li></ol> */
      const rapid::String32 MOBILITY_METHOD_UNDOCK = "undock";

      //@copy-declaration /** Unperches Astrobee from a handrail.<p/>The nominal unperching sequence is as follows:<ol><li>Switch to "MappedLandmarks" localization pipeline (the default for general-purpose navigation).</li><li>Spin up impellers.</li><li>Open gripper, releasing the handrail.</li><li>Move to perch approach point.</li><li>Stow arm, as in Arm.stowArm.</li></ol> */
      const rapid::String32 MOBILITY_METHOD_UNPERCH = "unperch";

      const rapid::String32 PLAN = "Plan";

      //@copy-declaration /** Pauses the running plan. The currently executing command will be aborted (equivalent to Mobility.stopAllMotion), and execution of subsequent commands will be delayed until the plan is resumed with a Plan.runPlan command. See plan.setPlan. */
      const rapid::String32 PLAN_METHOD_PAUSE_PLAN = "pausePlan";

      //@copy-declaration /** Runs the currently loaded plan. If the plan was previously paused with Plan.pausePlan, this command will resume execution where it previously left off. See plan.setPlan. */
      const rapid::String32 PLAN_METHOD_RUN_PLAN = "runPlan";

      //@copy-declaration /** Loads the most recently uplinked plan.<p/>An Astrobee plan is specified as a JSON-formatted fplan file that contains a list of stations (locations to visit), segments (trajectories for flying between stations), and commands to execute at stations. Plans are generated using the control station plan editor. Sample fplan files can be found in the astrobee/astrobee/plans folder.<p/>The Astrobee control station implements the protocol for managing plans:<ol><li>Uplink a new fplan file using the RAPID compressed file protocol over DDS. (File uplink is not considered a command, so it does not appear in this command dictionary).</li><li>Send this Plan.setPlan command to load the uplinked fplan file. Any errors in the fplan will be reported at this time. Once the plan is loaded, it is initially in the 'paused' state.</li><li>Use the Plan.runPlan / Plan.pausePlan commands to start / stop plan execution. Note that after a plan is paused using Plan.pausePlan, Plan.runPlan will resume plan execution at the beginning of the first plan step that was not fully completed. In the case that a trajectory segment is paused partway through, resuming the plan will cause the robot to fly back to the beginning of the segment and execute the whole segment again. If this behavior is not desired, you can use Plan.skipNextStep.</li></ol>Other related commands include:<ul><li>Plan.skipNextStep: Skips the next step of the currently loaded (and paused) plan.</li><li>Plan.wait: Same as Plan.pausePlan, but execution will resume automatically after the specified wait duration.</li></ul> */
      const rapid::String32 PLAN_METHOD_SET_PLAN = "setPlan";

      //@copy-declaration /** Skips the next step of the currently loaded plan (the step could be a trajectory segment or a command at a station). The plan must be paused. See plan.setPlan. */
      const rapid::String32 PLAN_METHOD_SKIP_PLAN_STEP = "skipPlanStep";

      //@copy-declaration /** Temporarily pauses the running plan. This command only affects plan execution, not individual teleoperated commands. Plan execution will resume automatically after the specified duration. See plan.setPlan. */
      const rapid::String32 PLAN_METHOD_WAIT = "wait";

      //@copy-declaration /** Seconds to pause */
      const rapid::String32 PLAN_METHOD_WAIT_PARAM_DURATION = "duration";
      const rapid::DataType PLAN_METHOD_WAIT_DTYPE_DURATION = rapid::RAPID_FLOAT;

      const rapid::String32 POWER = "Power";

      //@copy-declaration /** Powers off a component within Astrobee. Note: to turn flashlights on or off, see Settings.setFlashlightBrightness. */
      const rapid::String32 POWER_METHOD_POWER_OFF_ITEM = "powerOffItem";

      //@copy-declaration /** Which component. Note: 'Front' means 'Forward'. */
      const rapid::String32 POWER_METHOD_POWER_OFF_ITEM_PARAM_WHICH = "which";
      const rapid::DataType POWER_METHOD_POWER_OFF_ITEM_DTYPE_WHICH = rapid::RAPID_STRING;

      //@copy-declaration /** Powers on a component within Astrobee. Note: to turn flashlights on or off, see Settings.setFlashlightBrightness. */
      const rapid::String32 POWER_METHOD_POWER_ON_ITEM = "powerOnItem";

      //@copy-declaration /** Which component. Note: 'Front' means 'Forward'. */
      const rapid::String32 POWER_METHOD_POWER_ON_ITEM_PARAM_WHICH = "which";
      const rapid::DataType POWER_METHOD_POWER_ON_ITEM_DTYPE_WHICH = rapid::RAPID_STRING;

      const rapid::String32 SETTINGS = "Settings";

      //@copy-declaration /** Sets camera parameters.<p/>The Astrobee camera control life cycle is as follows:<ul><li>When the Astrobee flight software stack is started, recording and streaming are initially disabled for all cameras, and the default camera parameters are as specified in the astrobee/config/cameras.config file.</li><li>For each camera, while recording and streaming are disabled, you may use this Settings.setCamera command to adjust its parameters.</li><li>For each camera, you may enable/disable recording imagery to onboard storage using Settings.setCameraRecording.</li><li>For each camera, you may enable/disable live imagery downlink using Settings.setCameraStreaming.</li></ul> */
      const rapid::String32 SETTINGS_METHOD_SET_CAMERA = "setCamera";

      //@copy-declaration /** Which camera */
      const rapid::String32 SETTINGS_METHOD_SET_CAMERA_PARAM_CAMERA_NAME = "cameraName";
      const rapid::DataType SETTINGS_METHOD_SET_CAMERA_DTYPE_CAMERA_NAME = rapid::RAPID_STRING;

      //@copy-declaration /** Cameras can both stream and record, potentially with different parameters (typically, you might downlink at lower frame rate and lower resolution). Use this field to specify which mode you want to change parameters for. */
      const rapid::String32 SETTINGS_METHOD_SET_CAMERA_PARAM_CAMERA_MODE = "cameraMode";
      const rapid::DataType SETTINGS_METHOD_SET_CAMERA_DTYPE_CAMERA_MODE = rapid::RAPID_STRING;

      //@copy-declaration /** The resolution of the images to produce, in pixels W x H. Specifying resolution smaller than the actual sensor resolution causes binning or downsampling. Only selected downsampling ratios are supported. Available resolutions are:<br/>- SciCam: 1920x1080, 1280x720, 960x540, 480x270. <br/>- NavCam, DockCam: 1280x960, 1024x768, 640x480, 320x240. <br/>- HazCam, PerchCam: 224x171 only */
      const rapid::String32 SETTINGS_METHOD_SET_CAMERA_PARAM_RESOLUTION = "resolution";
      const rapid::DataType SETTINGS_METHOD_SET_CAMERA_DTYPE_RESOLUTION = rapid::RAPID_STRING;

      //@copy-declaration /** Frame rate to send. Maximum frame rate varies by camera:<br/>- SciCam: 30 Hz <br/>- NavCam, DockCam: 15 Hz<br/>- HazCam, PerchCam: 5 Hz */
      const rapid::String32 SETTINGS_METHOD_SET_CAMERA_PARAM_FRAME_RATE = "frameRate";
      const rapid::DataType SETTINGS_METHOD_SET_CAMERA_DTYPE_FRAME_RATE = rapid::RAPID_FLOAT;

      //@copy-declaration /** Only used for SciCam. Sets target bitrate used in streaming video encoder. Lower bitrate may reduce video quality. */
      const rapid::String32 SETTINGS_METHOD_SET_CAMERA_PARAM_BANDWIDTH = "bandwidth";
      const rapid::DataType SETTINGS_METHOD_SET_CAMERA_DTYPE_BANDWIDTH = rapid::RAPID_FLOAT;

      //@copy-declaration /** Sets camera video onboard recording on/off.<p/>Note: For the SciCam, this command actually enables independent recording of H.264 compressed video. For other cameras, this command enables publishing image frames to a topic designated for onboard recording together with other telemetry, but you also need to double-check that the Settings.setDataToDisk configuration will actually log that telemetry topic.<p/>See Settings.setCamera for context. */
      const rapid::String32 SETTINGS_METHOD_SET_CAMERA_RECORDING = "setCameraRecording";

      //@copy-declaration /** Which camera */
      const rapid::String32 SETTINGS_METHOD_SET_CAMERA_RECORDING_PARAM_CAMERA_NAME = "cameraName";
      const rapid::DataType SETTINGS_METHOD_SET_CAMERA_RECORDING_DTYPE_CAMERA_NAME = rapid::RAPID_STRING;

      //@copy-declaration /** Set to true/false to enable/disable camera video onboard recording. */
      const rapid::String32 SETTINGS_METHOD_SET_CAMERA_RECORDING_PARAM_RECORD = "record";
      const rapid::DataType SETTINGS_METHOD_SET_CAMERA_RECORDING_DTYPE_RECORD = rapid::RAPID_BOOL;

      //@copy-declaration /** Sets camera streaming live video to the ground on/off.<p/>The SciCam streams H.264 compressed video via RTSP. All other cameras publish independent image frames via DDS.<p/>See Settings.setCamera for context. */
      const rapid::String32 SETTINGS_METHOD_SET_CAMERA_STREAMING = "setCameraStreaming";

      //@copy-declaration /** Which camera */
      const rapid::String32 SETTINGS_METHOD_SET_CAMERA_STREAMING_PARAM_CAMERA_NAME = "cameraName";
      const rapid::DataType SETTINGS_METHOD_SET_CAMERA_STREAMING_DTYPE_CAMERA_NAME = rapid::RAPID_STRING;

      //@copy-declaration /** Set to true/false to enable/disable streaming live video to the ground. */
      const rapid::String32 SETTINGS_METHOD_SET_CAMERA_STREAMING_PARAM_STREAM = "stream";
      const rapid::DataType SETTINGS_METHOD_SET_CAMERA_STREAMING_DTYPE_STREAM = rapid::RAPID_BOOL;

      //@copy-declaration /** Enables/disables obstacle checking */
      const rapid::String32 SETTINGS_METHOD_SET_CHECK_OBSTACLES = "setCheckObstacles";

      //@copy-declaration /** Set to true/false to enable/disable obstacle checking. */
      const rapid::String32 SETTINGS_METHOD_SET_CHECK_OBSTACLES_PARAM_CHECK_OBSTACLES = "checkObstacles";
      const rapid::DataType SETTINGS_METHOD_SET_CHECK_OBSTACLES_DTYPE_CHECK_OBSTACLES = rapid::RAPID_BOOL;

      //@copy-declaration /** Enables/disables keepout zone checking. See Settings.setZones. */
      const rapid::String32 SETTINGS_METHOD_SET_CHECK_ZONES = "setCheckZones";

      //@copy-declaration /** Set to true/false to enable/disable keepout zone checking. */
      const rapid::String32 SETTINGS_METHOD_SET_CHECK_ZONES_PARAM_CHECK_ZONES = "checkZones";
      const rapid::DataType SETTINGS_METHOD_SET_CHECK_ZONES_DTYPE_CHECK_ZONES = rapid::RAPID_BOOL;

      //@copy-declaration /** Not implemented. This commmand is intended to enable/disable auto-return to the dock, under the assumption that auto-return will eventually be configured in Astrobee's fault table as the automatic fault response for a low-battery fault. The flag is currently ignored because auto-return has not been sufficiently tested and is not used in the fault table. See Mobility.autoReturn. */
      const rapid::String32 SETTINGS_METHOD_SET_ENABLE_AUTO_RETURN = "setEnableAutoReturn";

      //@copy-declaration /** Set to true/false to enable/disable auto-return. */
      const rapid::String32 SETTINGS_METHOD_SET_ENABLE_AUTO_RETURN_PARAM_ENABLE_AUTO_RETURN = "enableAutoReturn";
      const rapid::DataType SETTINGS_METHOD_SET_ENABLE_AUTO_RETURN_DTYPE_ENABLE_AUTO_RETURN = rapid::RAPID_BOOL;

      //@copy-declaration /** For expert use only. Changes the semantics of how Astrobee executes fplan trajectory segments.<p/>A segment specifies the motion trajectory between stations in the plan. Within the segment, desired pose and velocity are smoothly interpolated functions of time over a time interval [t0, t1]. Plans created by the Astrobee control station plan editor always specify each segment's time values relative to the start of that segment's execution (i.e. t0 = 0). These plans must be executed in immediate mode, so called because when execution reaches a new segment, the executive and choreographer immediately 'start the clock' on executing the timed trajectory. In principle, if you want to synchronize motion of multiple robots, it could be useful to have the interval [t0, t1] specified using absolute timestamps. That is the behavior when immediate mode is disabled. The timestamp t0 is interpreted as absolute time using ROS conventions (usually UNIX epoch when running on real hardware, but could be any arbitrary time scale when running in simulation), and the start of motion on the segment would be delayed until the current time t = t0.<p/>At this time, we cannot recommend disabling immediate mode to achieve synchronization, due to the following concerns: (1) execution with absolute timestamps has never really been tested, and may be buggy, (2) the control station plan editor doesn't provide any way to generate segments with absolute timestamps, (3) since it is seldom possible to predict exactly when ISS conditions will be right to begin a multi-robot activity, it would be awkward in practice to have the exact absolute timing of segments hard-coded into the plans.<p/>As an alternative way to synchronize motion, you can execute with immediate mode enabled as usual, but take special care to minimize any skew in start time. Upload the plans in advance, use the Mobility.prepare command to get the robots ready to move, and then run the plans simultaneously. Astrobee to Astrobee communication is in the works, and may eventually enable synchronizing Astrobees in a better way. */
      const rapid::String32 SETTINGS_METHOD_SET_ENABLE_IMMEDIATE = "setEnableImmediate";

      //@copy-declaration /** Set to true/false to enable/disable immediate mode motion control. */
      const rapid::String32 SETTINGS_METHOD_SET_ENABLE_IMMEDIATE_PARAM_ENABLE_IMMEDIATE = "enableImmediate";
      const rapid::DataType SETTINGS_METHOD_SET_ENABLE_IMMEDIATE_DTYPE_ENABLE_IMMEDIATE = rapid::RAPID_BOOL;

      //@copy-declaration /** Allows Astrobee to re-plan if it detects an obstacle too close to its forward trajectory. Enabling replanning only makes sense when you are using a planner that is able to plan around obstacles. (See Setting.setPlanner. As of 5/2021, only the QP planner can plan around obstacles). */
      const rapid::String32 SETTINGS_METHOD_SET_ENABLE_REPLAN = "setEnableReplan";

      //@copy-declaration /** If true, when Astrobee detects an obstacle too close to its forward trajectory, after the robot comes to a stop, the choreographer will automatically request a new trajectory from the current configured planner. If false, the robot will stop and wait for operator assistance. */
      const rapid::String32 SETTINGS_METHOD_SET_ENABLE_REPLAN_PARAM_ENABLE_REPLAN = "enableReplan";
      const rapid::DataType SETTINGS_METHOD_SET_ENABLE_REPLAN_DTYPE_ENABLE_REPLAN = rapid::RAPID_BOOL;

      //@copy-declaration /** Sets flashlight brightness. */
      const rapid::String32 SETTINGS_METHOD_SET_FLASHLIGHT_BRIGHTNESS = "setFlashlightBrightness";

      //@copy-declaration /** Which flashlight. Note: 'Back' means 'Aft' and 'Front' means 'Forward'. */
      const rapid::String32 SETTINGS_METHOD_SET_FLASHLIGHT_BRIGHTNESS_PARAM_WHICH = "which";
      const rapid::DataType SETTINGS_METHOD_SET_FLASHLIGHT_BRIGHTNESS_DTYPE_WHICH = rapid::RAPID_STRING;

      //@copy-declaration /** Brightness value between 0 (off) and 1 (full brightness). Note that full brightness of an Astrobee flashlight is similar to that of an ordinary pocket flashlight, and may be uncomfortably bright if pointed toward crew eyes. When working with crew, it is advisable to use lower brightness values and/or take steps to avoid pointing the flashlight toward crew. */
      const rapid::String32 SETTINGS_METHOD_SET_FLASHLIGHT_BRIGHTNESS_PARAM_BRIGHTNESS = "brightness";
      const rapid::DataType SETTINGS_METHOD_SET_FLASHLIGHT_BRIGHTNESS_DTYPE_BRIGHTNESS = rapid::RAPID_FLOAT;

      //@copy-declaration /** Enables/disables holonomic mode.<p/>Holonomic mode is sometimes called 'blind flying' because it relaxes the constraint to always point the HazCam in the direction of motion while translating in order to enable obstacle detection. When holonomic mode is enabled, the default trapezoidal planner will simultaneously translate to the target position and rotate to the target attitude. */
      const rapid::String32 SETTINGS_METHOD_SET_HOLONOMIC_MODE = "setHolonomicMode";

      //@copy-declaration /** Set to true/false to enable/disable holonomic mode. */
      const rapid::String32 SETTINGS_METHOD_SET_HOLONOMIC_MODE_PARAM_ENABLE_HOLONOMIC = "enableHolonomic";
      const rapid::DataType SETTINGS_METHOD_SET_HOLONOMIC_MODE_DTYPE_ENABLE_HOLONOMIC = rapid::RAPID_BOOL;

      //@copy-declaration /** Sets mass and inertia parameters for Astrobee control.<p/>The default inertial parameters for each robot are stored in an onboard configuration file, and should not need to be changed as long as the Astrobee remains in its baseline configuration (four batteries and no payloads installed). However, the inertial parameters may vary when the robot configuration changes. Examples are when a payload is installed or reconfigured (like deploying the arm). When configuration changes for a planned activity are known in advance, the standard management approach is to specify them in the inertiaConfig field of the relevant fplan. This command provides the same parameter update capability, but with more flexibility as to when it is applied (for example, you can change in the middle of a plan, during teleoperation, or when commanded by a guest science app). */
      const rapid::String32 SETTINGS_METHOD_SET_INERTIA = "setInertia";

      //@copy-declaration /** An optional profile name for this inertia profile. The name has no functional effect, but may be reported in status telemetry and operator displays. */
      const rapid::String32 SETTINGS_METHOD_SET_INERTIA_PARAM_NAME = "name";
      const rapid::DataType SETTINGS_METHOD_SET_INERTIA_DTYPE_NAME = rapid::RAPID_STRING;

      //@copy-declaration /** Mass of the Astrobee assembly */
      const rapid::String32 SETTINGS_METHOD_SET_INERTIA_PARAM_MASS = "mass";
      const rapid::DataType SETTINGS_METHOD_SET_INERTIA_DTYPE_MASS = rapid::RAPID_FLOAT;

      //@copy-declaration /** Center of mass of the Astrobee assembly. Specified relative to Astrobee's body frame. */
      const rapid::String32 SETTINGS_METHOD_SET_INERTIA_PARAM_CENTER_OF_MASS = "centerOfMass";
      const rapid::DataType SETTINGS_METHOD_SET_INERTIA_DTYPE_CENTER_OF_MASS = rapid::RAPID_VEC3d;

      //@copy-declaration /** The moment of inertia tensor. Must be a symmetric matrix. Specified relative to the center of mass. */
      const rapid::String32 SETTINGS_METHOD_SET_INERTIA_PARAM_MATRIX = "matrix";
      const rapid::DataType SETTINGS_METHOD_SET_INERTIA_DTYPE_MATRIX = rapid::RAPID_MAT33f;

      //@copy-declaration /** Changes the value of Astrobee operating limits */
      const rapid::String32 SETTINGS_METHOD_SET_OPERATING_LIMITS = "setOperatingLimits";

      //@copy-declaration /** An optional profile name for this set of operating limits. The name has no functional effect, but may be reported in status telemetry and operator displays. */
      const rapid::String32 SETTINGS_METHOD_SET_OPERATING_LIMITS_PARAM_PROFILE_NAME = "profileName";
      const rapid::DataType SETTINGS_METHOD_SET_OPERATING_LIMITS_DTYPE_PROFILE_NAME = rapid::RAPID_STRING;

      //@copy-declaration /** Setting the flight mode updates the GN&C gains, hard limits, tolerances, etc., as specified in the world config file. See e.g. astrobee/astrobee/config/worlds/iss.config. Note that executing certain operations, such as docking, automatically switches the flight mode as needed. Values:<ul><li>Off: Turns off propulsion.</li><li>Quiet: Sets propulsion impeller speed to QUIET (low speed) with gains and limits tuned to safely fly within the reduced performance.</li><li>Nominal: Sets propulsion impeller speed to NOMINAL (medium speed), with gains and limits tuned for typical utility flying.</li><li>Difficult: Sets propulsion impeller speed to AGGRESSIVE (high speed), with gains and limits tuned for maximum performance.</li><li>Precision: Sets propulsion impeller speed to AGGRESSIVE, with gains and limits tuned for precise motion (slow speed, tight position and attitude tolerances).</li></ul> */
      const rapid::String32 SETTINGS_METHOD_SET_OPERATING_LIMITS_PARAM_FLIGHT_MODE = "flightMode";
      const rapid::DataType SETTINGS_METHOD_SET_OPERATING_LIMITS_DTYPE_FLIGHT_MODE = rapid::RAPID_STRING;

      //@copy-declaration /** The maximum linear velocity to target while translating */
      const rapid::String32 SETTINGS_METHOD_SET_OPERATING_LIMITS_PARAM_TARGET_LINEAR_VELOCITY = "targetLinearVelocity";
      const rapid::DataType SETTINGS_METHOD_SET_OPERATING_LIMITS_DTYPE_TARGET_LINEAR_VELOCITY = rapid::RAPID_FLOAT;

      //@copy-declaration /** The maximum linear acceleration to target while translating */
      const rapid::String32 SETTINGS_METHOD_SET_OPERATING_LIMITS_PARAM_TARGET_LINEAR_ACCELERATION = "targetLinearAcceleration";
      const rapid::DataType SETTINGS_METHOD_SET_OPERATING_LIMITS_DTYPE_TARGET_LINEAR_ACCELERATION = rapid::RAPID_FLOAT;

      //@copy-declaration /** The maximum angular velocity to target while rotating */
      const rapid::String32 SETTINGS_METHOD_SET_OPERATING_LIMITS_PARAM_TARGET_ANGULAR_VELOCITY = "targetAngularVelocity";
      const rapid::DataType SETTINGS_METHOD_SET_OPERATING_LIMITS_DTYPE_TARGET_ANGULAR_VELOCITY = rapid::RAPID_FLOAT;

      //@copy-declaration /** The maximum angular acceleration to target while rotating */
      const rapid::String32 SETTINGS_METHOD_SET_OPERATING_LIMITS_PARAM_TARGET_ANGULAR_ACCELERATION = "targetAngularAcceleration";
      const rapid::DataType SETTINGS_METHOD_SET_OPERATING_LIMITS_DTYPE_TARGET_ANGULAR_ACCELERATION = rapid::RAPID_FLOAT;

      //@copy-declaration /** Minimum distance margin to maintain away from obstacles */
      const rapid::String32 SETTINGS_METHOD_SET_OPERATING_LIMITS_PARAM_COLLISION_DISTANCE = "collisionDistance";
      const rapid::DataType SETTINGS_METHOD_SET_OPERATING_LIMITS_DTYPE_COLLISION_DISTANCE = rapid::RAPID_FLOAT;

      //@copy-declaration /** Switches which trajectory planner is used when Astrobee needs to generate a trajectory to reach a target pose. Astrobee uses its trajectory planner when it receives a teleoperation motion command. However, when an fplan is generated by the Astrobee control station plan editor, it normally contains pre-computed trajectories for its motion segments; when Astrobee executes these fplans, the onboard trajectory planner is not used. */
      const rapid::String32 SETTINGS_METHOD_SET_PLANNER = "setPlanner";

      //@copy-declaration /** Which planner to use:<ul><li>Trapezoidal planner: Generates a straight-line trajectory from the start position to the target position, using trapezoidal velocity profiles for translation and rotation. If holonomic mode is disabled (usual case), the robot will (1) rotate to face the target position, (2) translate to the target position while facing forward, (3) rotate to the target attitude. If holonomic mode is enabled, the robot will simultaneously translate along a straight line to the target position while rotating to the target attitude.</li><li>QP planner: An experimental planner that generates a curved trajectory from start to target, avoiding intervening obstacles. As of 10/2020, using the QP planner is not recommended, because it has not yet been tested on the ISS.</li></ul> */
      const rapid::String32 SETTINGS_METHOD_SET_PLANNER_PARAM_PLANNER = "planner";
      const rapid::DataType SETTINGS_METHOD_SET_PLANNER_DTYPE_PLANNER = rapid::RAPID_STRING;

      //@copy-declaration /** Changes the frequency at which one DDS telemetry topic is published. */
      const rapid::String32 SETTINGS_METHOD_SET_TELEMETRY_RATE = "setTelemetryRate";

      //@copy-declaration /** The DDS telemetry topic to manage. Note: As of Oct 2020, the "CommStatus" topic is not implemented. */
      const rapid::String32 SETTINGS_METHOD_SET_TELEMETRY_RATE_PARAM_TELEMETRY_NAME = "telemetryName";
      const rapid::DataType SETTINGS_METHOD_SET_TELEMETRY_RATE_DTYPE_TELEMETRY_NAME = rapid::RAPID_STRING;

      //@copy-declaration /** The frequency for publishing the topic. */
      const rapid::String32 SETTINGS_METHOD_SET_TELEMETRY_RATE_PARAM_RATE = "rate";
      const rapid::DataType SETTINGS_METHOD_SET_TELEMETRY_RATE_DTYPE_RATE = rapid::RAPID_FLOAT;

      //@copy-declaration /** Loads the most recently uplinked keepout zones file.<p/>The Astrobee control station implements the protocol for managing keepout zones:<ol><li>Uplink a new keepout zone file using the RAPID compressed file protocol over DDS. (File uplink is not considered a command, so it does not appear in this command dictionary).</li><li>Send this Settings.setZones command to load the uplinked zones file. Any errors in the file will be reported at this time.</li><li>Use the Settings.setCheckZones command to enable/disable keepout zone checking.</li></ol> */
      const rapid::String32 SETTINGS_METHOD_SET_ZONES = "setZones";

      const rapid::String32 ADMIN_LOCALIZATION_MODE_NONE = "None";
      const rapid::String32 ADMIN_LOCALIZATION_MODE_MAPPED_LANDMARKS = "MappedLandmarks";
      const rapid::String32 ADMIN_LOCALIZATION_MODE_ARTAGS = "ARTags";
      const rapid::String32 ADMIN_LOCALIZATION_MODE_HANDRAIL = "Handrail";
      const rapid::String32 ADMIN_LOCALIZATION_MODE_PERCH = "Perch";
      const rapid::String32 ADMIN_LOCALIZATION_MODE_TRUTH = "Truth";

      const rapid::String32 ARM_ACTION_TYPE_PAN = "Pan";
      const rapid::String32 ARM_ACTION_TYPE_TILT = "Tilt";
      const rapid::String32 ARM_ACTION_TYPE_BOTH = "Both";

      const rapid::String32 POWER_POWERED_COMPONENT_LASER_POINTER = "Laser Pointer";
      const rapid::String32 POWER_POWERED_COMPONENT_PAYLOAD_TOP_AFT = "Payload Top Aft";
      const rapid::String32 POWER_POWERED_COMPONENT_PAYLOAD_BOTTOM_AFT = "Payload Bottom Aft";
      const rapid::String32 POWER_POWERED_COMPONENT_PAYLOAD_BOTTOM_FRONT = "Payload Bottom Front";
      const rapid::String32 POWER_POWERED_COMPONENT_PMCS_AND_SIGNAL_LIGHTS = "PMC";

      const rapid::String32 SETTINGS_CAMERA_MODE_BOTH = "Both";
      const rapid::String32 SETTINGS_CAMERA_MODE_RECORDING = "Recording";
      const rapid::String32 SETTINGS_CAMERA_MODE_STREAMING = "Streaming";

      const rapid::String32 SETTINGS_CAMERA_NAME_SCI = "Science";
      const rapid::String32 SETTINGS_CAMERA_NAME_NAV = "Navigation";
      const rapid::String32 SETTINGS_CAMERA_NAME_HAZ = "Hazard";
      const rapid::String32 SETTINGS_CAMERA_NAME_DOCK = "Dock";
      const rapid::String32 SETTINGS_CAMERA_NAME_PERCH = "Perch";

      const rapid::String32 SETTINGS_CAMERA_RESOLUTION_224X171 = "224x171";
      const rapid::String32 SETTINGS_CAMERA_RESOLUTION_320X240 = "320x240";
      const rapid::String32 SETTINGS_CAMERA_RESOLUTION_480X270 = "480x270";
      const rapid::String32 SETTINGS_CAMERA_RESOLUTION_640X480 = "640x480";
      const rapid::String32 SETTINGS_CAMERA_RESOLUTION_960X540 = "960x540";
      const rapid::String32 SETTINGS_CAMERA_RESOLUTION_1024X768 = "1024x768";
      const rapid::String32 SETTINGS_CAMERA_RESOLUTION_1280X720 = "1280x720";
      const rapid::String32 SETTINGS_CAMERA_RESOLUTION_1280X960 = "1280x960";
      const rapid::String32 SETTINGS_CAMERA_RESOLUTION_1920X1080 = "1920x1080";

      const rapid::String32 SETTINGS_FLASHLIGHT_LOCATION_BACK = "Back";
      const rapid::String32 SETTINGS_FLASHLIGHT_LOCATION_FRONT = "Front";

      const rapid::String32 SETTINGS_FLIGHT_MODE_OFF = "off";
      const rapid::String32 SETTINGS_FLIGHT_MODE_QUIET = "quiet";
      const rapid::String32 SETTINGS_FLIGHT_MODE_NOMINAL = "nominal";
      const rapid::String32 SETTINGS_FLIGHT_MODE_DIFFICULT = "difficult";
      const rapid::String32 SETTINGS_FLIGHT_MODE_PRECISION = "precision";

      const rapid::String32 SETTINGS_PLANNER_TYPE_TRAPEZOIDAL = "trapezoidal";
      const rapid::String32 SETTINGS_PLANNER_TYPE_QUADRATIC_PROGRAM = "qp";

      const rapid::String32 SETTINGS_TELEMETRY_TYPE_COMM_STATUS = "CommStatus";
      const rapid::String32 SETTINGS_TELEMETRY_TYPE_CPU_STATE = "CpuState";
      const rapid::String32 SETTINGS_TELEMETRY_TYPE_DISK_STATE = "DiskState";
      const rapid::String32 SETTINGS_TELEMETRY_TYPE_EKF_STATE = "EkfState";
      const rapid::String32 SETTINGS_TELEMETRY_TYPE_GNC_STATE = "GncState";
      const rapid::String32 SETTINGS_TELEMETRY_TYPE_PMC_CMD_STATE = "PmcCmdState";
      const rapid::String32 SETTINGS_TELEMETRY_TYPE_POSITION = "Position";
      const rapid::String32 SETTINGS_TELEMETRY_TYPE_SPARSE_MAPPING_POSE = "SparseMappingPose";


    };
  };
};
