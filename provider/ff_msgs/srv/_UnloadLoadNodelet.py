# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from ff_msgs/UnloadLoadNodeletRequest.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class UnloadLoadNodeletRequest(genpy.Message):
  _md5sum = "7b447d24c984d59cef0d4a86160190f3"
  _type = "ff_msgs/UnloadLoadNodeletRequest"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """###########################################################################
#           Copyright 2017 Intelligent Robotics Group, NASA ARC           #
###########################################################################
# This service is used by the system monitor to load and unload nodelets. #
###########################################################################

bool load             # If true load the nodelet. Else unload the nodelet.

string name           # Name of nodelet. Needed for both unload and load.

# Type of nodelet ("namespace/classname"). Needed for load. May not be needed
# if the type is specified in the system monitor config.
string type

# Name of nodelet manager. Needed for both load and unload. May not be needed if
# the system monitor received a heartbeat before being unloaded.
string manager_name

string[] remap_source_args  # Leave blank if no source args. Needed for load.
string[] remap_target_args  # Leave blank if no target args. Needed for load.
string[] my_argv            # Leave blank if none. Needed for load
string bond_id  # Not entirely sure what this is, leave blank. Needed for load.
"""
  __slots__ = ['load','name','type','manager_name','remap_source_args','remap_target_args','my_argv','bond_id']
  _slot_types = ['bool','string','string','string','string[]','string[]','string[]','string']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       load,name,type,manager_name,remap_source_args,remap_target_args,my_argv,bond_id

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(UnloadLoadNodeletRequest, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.load is None:
        self.load = False
      if self.name is None:
        self.name = ''
      if self.type is None:
        self.type = ''
      if self.manager_name is None:
        self.manager_name = ''
      if self.remap_source_args is None:
        self.remap_source_args = []
      if self.remap_target_args is None:
        self.remap_target_args = []
      if self.my_argv is None:
        self.my_argv = []
      if self.bond_id is None:
        self.bond_id = ''
    else:
      self.load = False
      self.name = ''
      self.type = ''
      self.manager_name = ''
      self.remap_source_args = []
      self.remap_target_args = []
      self.my_argv = []
      self.bond_id = ''

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.load
      buff.write(_get_struct_B().pack(_x))
      _x = self.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.type
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.manager_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.remap_source_args)
      buff.write(_struct_I.pack(length))
      for val1 in self.remap_source_args:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.remap_target_args)
      buff.write(_struct_I.pack(length))
      for val1 in self.remap_target_args:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.my_argv)
      buff.write(_struct_I.pack(length))
      for val1 in self.my_argv:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      _x = self.bond_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 1
      (self.load,) = _get_struct_B().unpack(str[start:end])
      self.load = bool(self.load)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.type = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.type = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.manager_name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.manager_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.remap_source_args = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.remap_source_args.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.remap_target_args = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.remap_target_args.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.my_argv = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.my_argv.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.bond_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.bond_id = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.load
      buff.write(_get_struct_B().pack(_x))
      _x = self.name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.type
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.manager_name
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.remap_source_args)
      buff.write(_struct_I.pack(length))
      for val1 in self.remap_source_args:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.remap_target_args)
      buff.write(_struct_I.pack(length))
      for val1 in self.remap_target_args:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      length = len(self.my_argv)
      buff.write(_struct_I.pack(length))
      for val1 in self.my_argv:
        length = len(val1)
        if python3 or type(val1) == unicode:
          val1 = val1.encode('utf-8')
          length = len(val1)
        buff.write(struct.Struct('<I%ss'%length).pack(length, val1))
      _x = self.bond_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 1
      (self.load,) = _get_struct_B().unpack(str[start:end])
      self.load = bool(self.load)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.type = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.type = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.manager_name = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.manager_name = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.remap_source_args = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.remap_source_args.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.remap_target_args = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.remap_target_args.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.my_argv = []
      for i in range(0, length):
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1 = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1 = str[start:end]
        self.my_argv.append(val1)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.bond_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.bond_id = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_B = None
def _get_struct_B():
    global _struct_B
    if _struct_B is None:
        _struct_B = struct.Struct("<B")
    return _struct_B
# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from ff_msgs/UnloadLoadNodeletResponse.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class UnloadLoadNodeletResponse(genpy.Message):
  _md5sum = "595e167cf0aa390cd33b2486e284d56d"
  _type = "ff_msgs/UnloadLoadNodeletResponse"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """int32 result

int32 SUCCESSFUL            = 1   # Success :)
# Un/load nodelet service offerred by the nodelet manager failed
int32 ROS_SERVICE_FAILED    = 2
# Node is not in the watchdog map i.e. the node doesn't have a heartbeat fault
# listed in the fault table. Thus the system monitor wasn't able to retrive the
# manager name.
int32 NODE_NOT_IN_MAP       = 3
# The operator didn't list the manager name in the command and the system
# monitor was unable to figure out what it should be.
int32 MANAGER_NAME_MISSING  = 4
# The operator didn't list the nodelet type and it wasn't specified in the
# system monitor config file
int32 TYPE_MISSING          = 5

"""
  # Pseudo-constants
  SUCCESSFUL = 1
  ROS_SERVICE_FAILED = 2
  NODE_NOT_IN_MAP = 3
  MANAGER_NAME_MISSING = 4
  TYPE_MISSING = 5

  __slots__ = ['result']
  _slot_types = ['int32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       result

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(UnloadLoadNodeletResponse, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.result is None:
        self.result = 0
    else:
      self.result = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.result
      buff.write(_get_struct_i().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 4
      (self.result,) = _get_struct_i().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.result
      buff.write(_get_struct_i().pack(_x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 4
      (self.result,) = _get_struct_i().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_i = None
def _get_struct_i():
    global _struct_i
    if _struct_i is None:
        _struct_i = struct.Struct("<i")
    return _struct_i
class UnloadLoadNodelet(object):
  _type          = 'ff_msgs/UnloadLoadNodelet'
  _md5sum = '7f19eb1a2a34b5a95695a9d88b20e227'
  _request_class  = UnloadLoadNodeletRequest
  _response_class = UnloadLoadNodeletResponse
